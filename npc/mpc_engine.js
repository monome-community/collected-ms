/*********************npc data routing enginepeter@flatflat.org*********************/////////////////////////// initial valzvar datareceived = 0;var mpcdat= "foo";////////////////////////autowatch = 1;init();function init(){psln('');psln('NPC');psln('');psln('');psln('peter segerstrom');psln('http://flatflat.org');psln('');psln('');psln('');psln('');psln('');psln('');  }// utilz// this just writes what the coll gives us into a global varfunction engine(bulk){       mpcdat = bulk;       datareceived = 1; }// this doesn't work write something that doesfunction copyseq(src,trg){ for(i = 1; i< 65 ;i++) {     for(j =0 ; j <4096; j++)    {        datareceived = 0;        outlet(0, src+'.'+i+'.'+j+'.seq');        if(datareceived)        {           // psln(mpcdat);            outlet(0, 'store '+trg+'.'+i+'.'+j+'.seq '+mpcdat);        }    }        }}function copypadset(src,trg){/*so we need to copy vce.dat, snd, pad, padset, pagetype*/zipthru('vce.dat');zipthru('snd');zipthru('pad');zipthru('padset');outlet(0, src+'.pagetype');if(datareceived){   // psln(mpcdat);    outlet(0, 'store '+trg+'.pagetype '+mpcdat);}psln("padset "+src+" copied to padset "+trg);///////////////////////////////////////////////////////////////////////////////////////////////////////////////// this will go through the whole thing and spit out stufffunction zipthru(data){ for(i = 0; i< 256;i++) {    datareceived = 0;    outlet(0, src+'.'+i+'.'+data);    if(datareceived)    {       // psln(mpcdat);        outlet(0, 'store '+trg+'.'+i+'.'+data+' '+mpcdat);    }        }}/////////////////////////////////////////////////////////////////////////////////////////////////////////////////}// FYI THIS WILL MERGE DATA IF YOU DON't CLEAR IT FIRST.function copytrack(seq,src,trg){var bank = new Array(4096); cleartrack(seq, trg); for(i = 0; i< 4096;i++) {    datareceived = 0;    outlet(0, seq+'.'+src+'.'+i+'.seq');    if(datareceived)    {        bank[i] = mpcdat;	//psln("doooooooo it "+mpcdat);       // outlet(0, 'store '+seq+'.'+trg+'.'+i+'.seq '+mpcdat);    } } // 1.seq.track.10, 256;         for(i = 0; i< 4096;i++)     {            if(bank[i] != null)            {               outlet(0, 'store '+seq+'.'+trg+'.'+i+'.seq '+bank[i]);            }     }              outlet(0, seq+'.seq.track.'+src);    if(datareceived)    {       // psln(mpcdat);        outlet(0, 'store '+seq+'.seq.track.'+trg+' '+mpcdat);    }                 psln('track copied');}function cleartrack(seq, trk){ for(i = 0; i< 4096;i++) {        //psln(mpcdat);        outlet(0, 'remove '+seq+'.'+trk+'.'+i+'.seq'); }}// calls up data from the collfunction get(page, num, type){    outlet(0, page+'.'+num+'.'+type);}// basic copy: copies any data index to any other data indexfunction copy(page, num, type, trgpage, trgnum){    get(page, num, type);        outlet(0, "store "+trgpage+"."+trgnum+"."+type+" "+mpcdat);    psln("mpc: "+type+" data copied");}function copypadall(page, num, type, trgnum){/*this will take a fully functional pad and write all it's data to another pad.  the question is whether or not to instantiate a new voice.  */}function psln(x){		post(x+"\n");}